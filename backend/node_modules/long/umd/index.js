// GENERATED FILE. DO NOT EDIT.
var Long = (function(exports) {
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
<<<<<<< HEAD
  
  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    // \0asm
    0, 97, 115, 109,
    // version 1
    1, 0, 0, 0,
    // section "type"
    1, 13, 2,
    // 0, () => i32
    96, 0, 1, 127,
    // 1, (i32, i32, i32, i32) => i32
    96, 4, 127, 127, 127, 127, 1, 127,
    // section "function"
    3, 7, 6,
    // 0, type 0
    0,
    // 1, type 1
    1,
    // 2, type 1
    1,
    // 3, type 1
    1,
    // 4, type 1
    1,
    // 5, type 1
    1,
    // section "global"
    6, 6, 1,
    // 0, "high", mutable i32
    127, 1, 65, 0, 11,
    // section "export"
    7, 50, 6,
    // 0, "mul"
    3, 109, 117, 108, 0, 1,
    // 1, "div_s"
    5, 100, 105, 118, 95, 115, 0, 2,
    // 2, "div_u"
    5, 100, 105, 118, 95, 117, 0, 3,
    // 3, "rem_s"
    5, 114, 101, 109, 95, 115, 0, 4,
    // 4, "rem_u"
    5, 114, 101, 109, 95, 117, 0, 5,
    // 5, "get_high"
    8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,
    // section "code"
    10, 191, 1, 6,
    // 0, "get_high"
    4, 0, 35, 0, 11,
    // 1, "mul"
    36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
    // 2, "div_s"
    36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
    // 3, "div_u"
    36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
    // 4, "rem_s"
    36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11,
    // 5, "rem_u"
    36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {
    // no wasm support :(
  }
  
=======
  // WebAssembly optimizations to do native i64 multiplication and divide
  var wasm = null;
  
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {// no wasm support :(
  }
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  function Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
<<<<<<< HEAD
    this.high = high | 0;
  
=======
  
    this.high = high | 0;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
<<<<<<< HEAD
    this.unsigned = !!unsigned;
  }
  
  // The internal representation of a long is the two given signed, 32-bit values.
=======
  
    this.unsigned = !!unsigned;
  } // The internal representation of a long is the two given signed, 32-bit values.
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  // We use 32-bit pieces because these are the size of integers on which
  // Javascript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within Javascript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.
  
  /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", {
    value: true
  });
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
<<<<<<< HEAD
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  
=======
  
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
<<<<<<< HEAD
  Long.isLong = isLong;
  
=======
  
  
  Long.isLong = isLong;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
<<<<<<< HEAD
  var INT_CACHE = {};
  
=======
  
  var INT_CACHE = {};
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
<<<<<<< HEAD
  var UINT_CACHE = {};
  
=======
  
  var UINT_CACHE = {};
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
<<<<<<< HEAD
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
=======
  
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
  
    if (unsigned) {
      value >>>= 0;
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      obj = fromBits(value, 0, true);
      if (cache) UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj) return cachedObj;
      }
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache) INT_CACHE[value] = obj;
      return obj;
    }
  }
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromInt = fromInt;
  
=======
  
  
  Long.fromInt = fromInt;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
<<<<<<< HEAD
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
=======
  
  function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (unsigned) {
      if (value < 0) return UZERO;
      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
<<<<<<< HEAD
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  
=======
  
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromNumber = fromNumber;
  
=======
  
  
  Long.fromNumber = fromNumber;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
<<<<<<< HEAD
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  
=======
  
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromBits = fromBits;
  
=======
  
  
  Long.fromBits = fromBits;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
  
  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
<<<<<<< HEAD
  function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
=======
  
  function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (typeof unsigned === 'number') {
      // For goog.math.long compatibility
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    var p;
    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
<<<<<<< HEAD
    }
  
    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
        value = parseInt(str.substring(i, i + size), radix);
=======
    } // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
  
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
<<<<<<< HEAD
    result.unsigned = unsigned;
    return result;
  }
  
=======
  
    result.unsigned = unsigned;
    return result;
  }
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromString = fromString;
  
=======
  
  
  Long.fromString = fromString;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
<<<<<<< HEAD
  function fromValue(val, unsigned) {
    if (typeof val === 'number') return fromNumber(val, unsigned);
    if (typeof val === 'string') return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }
  
  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  Long.fromValue = fromValue;
  
  // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
=======
  
  function fromValue(val, unsigned) {
    if (typeof val === 'number') return fromNumber(val, unsigned);
    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
  
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }
  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  
  
  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  // no runtime penalty for these.
  
  /**
   * @type {number}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_16_DBL = 1 << 16;
  
=======
  
  var TWO_PWR_16_DBL = 1 << 16;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {number}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_24_DBL = 1 << 24;
  
=======
  
  var TWO_PWR_24_DBL = 1 << 24;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {number}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  
=======
  
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {number}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  
=======
  
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {number}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  
=======
  
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @const
   * @inner
   */
<<<<<<< HEAD
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  
=======
  
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var ZERO = fromInt(0);
  
=======
  
  var ZERO = fromInt(0);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Signed zero.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.ZERO = ZERO;
  
=======
  
  Long.ZERO = ZERO;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var UZERO = fromInt(0, true);
  
=======
  
  var UZERO = fromInt(0, true);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Unsigned zero.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.UZERO = UZERO;
  
=======
  
  Long.UZERO = UZERO;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var ONE = fromInt(1);
  
=======
  
  var ONE = fromInt(1);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Signed one.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.ONE = ONE;
  
=======
  
  Long.ONE = ONE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var UONE = fromInt(1, true);
  
=======
  
  var UONE = fromInt(1, true);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Unsigned one.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.UONE = UONE;
  
=======
  
  Long.UONE = UONE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var NEG_ONE = fromInt(-1);
  
=======
  
  var NEG_ONE = fromInt(-1);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Signed negative one.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.NEG_ONE = NEG_ONE;
  
=======
  
  Long.NEG_ONE = NEG_ONE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
  
=======
  
  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Maximum signed value.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.MAX_VALUE = MAX_VALUE;
  
=======
  
  Long.MAX_VALUE = MAX_VALUE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
  
=======
  
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  
=======
  
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @type {!Long}
   * @inner
   */
<<<<<<< HEAD
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
  
=======
  
  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Minimum signed value.
   * @type {!Long}
   */
<<<<<<< HEAD
  Long.MIN_VALUE = MIN_VALUE;
  
=======
  
  Long.MIN_VALUE = MIN_VALUE;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * @alias Long.prototype
   * @inner
   */
<<<<<<< HEAD
  var LongPrototype = Long.prototype;
  
=======
  
  var LongPrototype = Long.prototype;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
<<<<<<< HEAD
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  
=======
  
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    if (this.isZero()) return '0';
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (this.isNegative()) {
      // Unsigned Longs are never negative
      if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
<<<<<<< HEAD
          div = this.div(radixLong),
          rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return '-' + this.neg().toString(radix);
    }
  
    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
      rem = this;
    var result = '';
    while (true) {
      var remDiv = rem.div(radixToPower),
        intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
        digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;else {
        while (digits.length < 6) digits = '0' + digits;
=======
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else return '-' + this.neg().toString(radix);
    } // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
  
  
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
  
    while (true) {
      var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero()) return digits + result;else {
        while (digits.length < 6) digits = '0' + digits;
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
        result = '' + digits + result;
      }
    }
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
<<<<<<< HEAD
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  
=======
  
  
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
<<<<<<< HEAD
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  
=======
  
  
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
<<<<<<< HEAD
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  
=======
  
  
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
<<<<<<< HEAD
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  
=======
  
  
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
<<<<<<< HEAD
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  
  /**
   * Tests if this Long can be safely represented as a JavaScript number.
   * @this {!Long}
   * @returns {boolean}
   */
  LongPrototype.isSafeInteger = function isSafeInteger() {
    // 2^53-1 is the maximum safe value
    var top11Bits = this.high >> 21;
    // [0, 2^53-1]
    if (!top11Bits) return true;
    // > 2^53-1
    if (this.unsigned) return false;
    // [-2^53, -1] except -2^53
    return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);
  };
  
=======
  
  
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
  
    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  
    return this.high != 0 ? bit + 33 : bit + 1;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  
=======
  
  
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.eqz = LongPrototype.isZero;
  
=======
  
  
  LongPrototype.eqz = LongPrototype.isZero;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  
=======
  
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  
=======
  
  
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  
=======
  
  
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
<<<<<<< HEAD
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  
  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
=======
  
  
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.equals = function equals(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
  };
<<<<<<< HEAD
  
  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.eq = LongPrototype.equals;
  
  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */other);
  };
  
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.neq = LongPrototype.notEquals;
  
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ne = LongPrototype.notEquals;
  
  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */other) < 0;
  };
  
  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lt = LongPrototype.lessThan;
  
  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */other) <= 0;
  };
  
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  
  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */other) > 0;
  };
  
  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gt = LongPrototype.greaterThan;
  
  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */other) >= 0;
  };
  
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  
  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
=======
  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.eq = LongPrototype.equals;
  /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
    /* validates */
    other);
  };
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.neq = LongPrototype.notEquals;
  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ne = LongPrototype.notEquals;
  /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
    /* validates */
    other) < 0;
  };
  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lt = LongPrototype.lessThan;
  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) <= 0;
  };
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
    /* validates */
    other) > 0;
  };
  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gt = LongPrototype.greaterThan;
  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
    /* validates */
    other) >= 0;
  };
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.compare = function compare(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(),
<<<<<<< HEAD
      otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1;
    // At this point the sign bits are the same
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  
  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|bigint|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.comp = LongPrototype.compare;
  
=======
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
  
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
  
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  
  
  LongPrototype.comp = LongPrototype.compare;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
<<<<<<< HEAD
  LongPrototype.neg = LongPrototype.negate;
  
  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} addend Addend
   * @returns {!Long} Sum
   */
  LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend);
  
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
=======
  
  
  LongPrototype.neg = LongPrototype.negate;
  /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  
  LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;
    var c48 = 0,
<<<<<<< HEAD
      c32 = 0,
      c16 = 0,
      c00 = 0;
=======
        c32 = 0,
        c16 = 0,
        c00 = 0;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
<<<<<<< HEAD
  
  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
=======
  /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
<<<<<<< HEAD
  
  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|bigint|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.sub = LongPrototype.subtract;
  
  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|bigint|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  
    // use wasm support if present
=======
  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  
  
  LongPrototype.sub = LongPrototype.subtract;
  /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (wasm) {
      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
<<<<<<< HEAD
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  
    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  
    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
=======
  
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  
    if (this.isNegative()) {
      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
  
  
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    // We can skip products that would overflow.
  
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;
    var c48 = 0,
<<<<<<< HEAD
      c32 = 0,
      c16 = 0,
      c00 = 0;
=======
        c32 = 0,
        c16 = 0,
        c00 = 0;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
<<<<<<< HEAD
  
  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|bigint|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.mul = LongPrototype.multiply;
  
=======
  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  
  
  LongPrototype.mul = LongPrototype.multiply;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
<<<<<<< HEAD
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero');
  
    // use wasm support if present
=======
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (wasm) {
      // guard against signed division overflow: the largest
      // negative number / -1 would be 1 larger than the largest
      // positive number, due to two's complement.
      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
        // be consistent with non-wasm code path
        return this;
      }
<<<<<<< HEAD
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
=======
  
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
  
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (!this.unsigned) {
      // This section is only relevant for signed longs and is derived from the
      // closure library as a whole.
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
        else if (divisor.eq(MIN_VALUE)) return ONE;else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      if (this.isNegative()) {
        if (divisor.isNegative()) return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      res = ZERO;
    } else {
      // The algorithm below has not been made for unsigned longs. It's therefore
      // required to take special care of the MSB prior to running it.
      if (!divisor.unsigned) divisor = divisor.toUnsigned();
      if (divisor.gt(this)) return UZERO;
<<<<<<< HEAD
      if (divisor.gt(this.shru(1)))
        // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    }
  
    // Repeat the following until the remainder is less than other:  find a
=======
      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
      res = UZERO;
    } // Repeat the following until the remainder is less than other:  find a
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
<<<<<<< HEAD
    rem = this;
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
  
      // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
        delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
        approxRes = fromNumber(approx),
        approxRem = approxRes.mul(divisor);
=======
  
  
    rem = this;
  
    while (rem.gte(divisor)) {
      // Approximate the result of division. This may be a little greater or
      // smaller than the actual value.
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
      // the smallest non-fractional digit, whichever is larger.
  
      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
      // that if it is too large, the product overflows and is negative.
      approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
<<<<<<< HEAD
      }
  
      // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
=======
      } // We know the answer can't be zero... and actually, zero would cause
      // infinite recursion since we would make no progress.
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
      if (approxRes.isZero()) approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
<<<<<<< HEAD
    return res;
  };
  
  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.div = LongPrototype.divide;
  
  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
  
    // use wasm support if present
=======
  
    return res;
  };
  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  
  
  LongPrototype.div = LongPrototype.divide;
  /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
<<<<<<< HEAD
    return this.sub(this.div(divisor).mul(divisor));
  };
  
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.mod = LongPrototype.modulo;
  
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|bigint|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.rem = LongPrototype.modulo;
  
=======
  
    return this.sub(this.div(divisor).mul(divisor));
  };
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  
  LongPrototype.mod = LongPrototype.modulo;
  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  
  LongPrototype.rem = LongPrototype.modulo;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
<<<<<<< HEAD
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  
=======
  
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
<<<<<<< HEAD
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  
=======
  
  
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
<<<<<<< HEAD
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  
=======
  
  
  LongPrototype.clz = LongPrototype.countLeadingZeros;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
<<<<<<< HEAD
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  
=======
  
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
<<<<<<< HEAD
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  
  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
=======
  
  
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.and = function and(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
<<<<<<< HEAD
  
  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
=======
  /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.or = function or(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
<<<<<<< HEAD
  
  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|bigint|string} other Other Long
   * @returns {!Long}
   */
=======
  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.xor = function xor(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
  LongPrototype.shl = LongPrototype.shiftLeft;
  
=======
  
  
  LongPrototype.shl = LongPrototype.shiftLeft;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
  LongPrototype.shr = LongPrototype.shiftRight;
  
=======
  
  
  LongPrototype.shr = LongPrototype.shiftRight;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  
=======
  
  
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
<<<<<<< HEAD
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  
=======
  
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
<<<<<<< HEAD
  LongPrototype.rotl = LongPrototype.rotateLeft;
  
=======
  
  
  LongPrototype.rotl = LongPrototype.rotateLeft;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
<<<<<<< HEAD
  LongPrototype.rotr = LongPrototype.rotateRight;
  
=======
  
  
  LongPrototype.rotr = LongPrototype.rotateRight;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
<<<<<<< HEAD
=======
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
  };
<<<<<<< HEAD
  
=======
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
<<<<<<< HEAD
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  
=======
  
  
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
<<<<<<< HEAD
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
      lo = this.low;
    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
  };
  
=======
  
  
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
<<<<<<< HEAD
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
      lo = this.low;
    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
  };
  
=======
  
  
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  
=======
  
  
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
<<<<<<< HEAD
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  
=======
  
  
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
<<<<<<< HEAD
=======
  
  
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
  
<<<<<<< HEAD
  // Support conversion to/from BigInt where available
  if (typeof BigInt === "function") {
    /**
     * Returns a Long representing the given big integer.
     * @function
     * @param {number} value The big integer value
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBigInt = function fromBigInt(value, unsigned) {
      var lowBits = Number(BigInt.asIntN(32, value));
      var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
      return fromBits(lowBits, highBits, unsigned);
    };
  
    // Override
    Long.fromValue = function fromValueWithBigInt(value, unsigned) {
      if (typeof value === "bigint") return fromBigInt(value, unsigned);
      return fromValue(value, unsigned);
    };
  
    /**
     * Converts the Long to its big integer representation.
     * @this {!Long}
     * @returns {bigint}
     */
    LongPrototype.toBigInt = function toBigInt() {
      var lowBigInt = BigInt(this.low >>> 0);
      var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
      return highBigInt << BigInt(32) | lowBigInt;
    };
  }
  var _default = exports.default = Long;
=======
  var _default = Long;
  exports.default = _default;
>>>>>>> 322f7e2915425488632c44548656ee1b0fe9ba65
  return "default" in exports ? exports.default : exports;
})({});
if (typeof define === 'function' && define.amd) define([], function() { return Long; });
else if (typeof module === 'object' && typeof exports === 'object') module.exports = Long;
